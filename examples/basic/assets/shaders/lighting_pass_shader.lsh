#shader vertex
#version 450

layout (location = 0) in vec3 a_pos;
layout (location = 1) in vec2 a_tex_coord;

layout (location = 0) out vec2 o_tex_coord;

void main() {
    o_tex_coord = a_tex_coord;
    gl_Position = vec4(a_pos, 1.0);
}

#shader fragment
#version 450

#include "common/camera.lsh"
#include "common/shadows.lsh"
#include "lighting/pbr.lsh"
#include "lighting/lights.lsh"

layout (location = 0) out vec4 frag_color;

layout (location = 0) in vec2 o_tex_coord;

layout (binding = 0) uniform sampler2D u_position_map;
layout (binding = 1) uniform sampler2D u_albedo_map;
layout (binding = 2) uniform sampler2D u_normal_map;
layout (binding = 3) uniform sampler2D u_rough_metal_ao_map;
layout (binding = 4) uniform sampler2D u_emissive_map;
layout (binding = 5) uniform samplerCube u_irradiance_map;
layout (binding = 6) uniform samplerCube u_prefilter_map;
layout (binding = 7) uniform sampler2D u_brdf_map;
layout (binding = 8) uniform sampler2D u_ambient_occlusion_map;
layout (binding = 9) uniform sampler2DArray u_cascades_shadow_map;
layout (binding = 10) uniform sampler2DArrayShadow u_cascades_shadow_pcf_map;
layout (binding = 11) uniform sampler2D u_random_angles_map;

uniform float u_skybox_intensity;
uniform vec4 u_skybox_tint;

float light_near_plane;
float light_far_plane;
float light_radius;

const vec2 Poisson64[64] = vec2[](
vec2(-0.934812, 0.366741),
vec2(-0.918943, -0.0941496),
vec2(-0.873226, 0.62389),
vec2(-0.8352, 0.937803),
vec2(-0.822138, -0.281655),
vec2(-0.812983, 0.10416),
vec2(-0.786126, -0.767632),
vec2(-0.739494, -0.535813),
vec2(-0.681692, 0.284707),
vec2(-0.61742, -0.234535),
vec2(-0.601184, 0.562426),
vec2(-0.607105, 0.847591),
vec2(-0.581835, -0.00485244),
vec2(-0.554247, -0.771111),
vec2(-0.483383, -0.976928),
vec2(-0.476669, -0.395672),
vec2(-0.439802, 0.362407),
vec2(-0.409772, -0.175695),
vec2(-0.367534, 0.102451),
vec2(-0.35313, 0.58153),
vec2(-0.341594, -0.737541),
vec2(-0.275979, 0.981567),
vec2(-0.230811, 0.305094),
vec2(-0.221656, 0.751152),
vec2(-0.214393, -0.0592364),
vec2(-0.204932, -0.483566),
vec2(-0.183569, -0.266274),
vec2(-0.123936, -0.754448),
vec2(-0.0859096, 0.118625),
vec2(-0.0610675, 0.460555),
vec2(-0.0234687, -0.962523),
vec2(-0.00485244, -0.373394),
vec2(0.0213324, 0.760247),
vec2(0.0359813, -0.0834071),
vec2(0.0877407, -0.730766),
vec2(0.14597, 0.281045),
vec2(0.18186, -0.529649),
vec2(0.188208, -0.289529),
vec2(0.212928, 0.063509),
vec2(0.23661, 0.566027),
vec2(0.266579, 0.867061),
vec2(0.320597, -0.883358),
vec2(0.353557, 0.322733),
vec2(0.404157, -0.651479),
vec2(0.410443, -0.413068),
vec2(0.413556, 0.123325),
vec2(0.46556, -0.176183),
vec2(0.49266, 0.55388),
vec2(0.506333, 0.876888),
vec2(0.535875, -0.885556),
vec2(0.615894, 0.0703452),
vec2(0.637135, -0.637623),
vec2(0.677236, -0.174291),
vec2(0.67626, 0.7116),
vec2(0.686331, -0.389935),
vec2(0.691031, 0.330729),
vec2(0.715629, 0.999939),
vec2(0.8493, -0.0485549),
vec2(0.863582, -0.85229),
vec2(0.890622, 0.850581),
vec2(0.898068, 0.633778),
vec2(0.92053, -0.355693),
vec2(0.933348, -0.62981),
vec2(0.95294, 0.156896));

vec3 sample_irradiance_map(vec3 normal) {
    return texture(u_irradiance_map, normal).rgb;
}

vec3 sample_prefilter_map(vec3 reflection_dir, float roughness) {
    const float MAX_REFLECTION_LOD = 4.0;
    float mip_level = roughness * MAX_REFLECTION_LOD;
    return textureLod(u_prefilter_map, reflection_dir, mip_level).rgb;
}

vec2 sample_brdf_lut_map(vec3 view_dir, vec3 normal, float roughness) {
    return texture(u_brdf_map, vec2(max(dot(normal, view_dir), 0.0), roughness)).rg;
}

vec2 shadow_pcf_rotate(vec2 uv, float angle)
{
    float s = sin(angle);
    float c = cos(angle);
    return vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
}

float shadow_pcf(vec2 projection_coords, float current_depth, float bias, uint cascade_index)
{
    vec2 texel_size = 1.0 / vec2(textureSize(u_cascades_shadow_map, 0));
    float shadow = 0.0;
    
    int pcf_samples = cascaded_shadows_parameters.pcf_horizontal_samples * cascaded_shadows_parameters.pcf_vertical_samples;
    for (int current_sample = 0; current_sample < pcf_samples; ++current_sample) {
        int x = current_sample % cascaded_shadows_parameters.pcf_horizontal_samples  - cascaded_shadows_parameters.pcf_horizontal_samples / 2;
        int y = current_sample / cascaded_shadows_parameters.pcf_horizontal_samples - cascaded_shadows_parameters.pcf_vertical_samples / 2;

        // Read a random vector from the texture
        vec2 random_rotation = texture(u_random_angles_map, vec2(x, y)).xy;

        // Introduce a rotation based on the random vector
        float angle = atan(random_rotation.y, random_rotation.x);
        vec2 rotated_coords = shadow_pcf_rotate(vec2(x, y), angle);

        float depth = texture(u_cascades_shadow_map, vec3(projection_coords.xy + rotated_coords * texel_size, cascade_index)).r;
        shadow += (current_depth - bias) > depth ? 1.0 : 0.0;
    }

    return shadow / float(pcf_samples);
}

float shadow_hard(vec2 projection_coords, float current_depth, float bias, uint cascade_index) {
    float depth = texture(u_cascades_shadow_map, vec3(projection_coords.xy, cascade_index)).r;
    float shadow = (current_depth - bias) > depth ? 1.0: 0.0;
    return shadow;
}

float calculate_directional_light_shadow(vec3 frag_pos, vec3 normal, vec3 light_dir) {
    vec4 frag_pos_view_space = camera.view_matrix * vec4(frag_pos, 1.0);
    float depth_value = abs(frag_pos_view_space.z);

    // Get the cascade shadow layer index.
    int cascade_index = 0;
    int cascades_count = 6;
    for (int i = 0; i < cascades_count - 1; ++i)
    {
        float cascade_distance = cascaded_shadows_parameters.cascade_plane_distances[i];

        if (depth_value < cascade_distance)
        {
            cascade_index = i + 1;
            break;
        }
    }

    vec4 frag_pos_light_space = u_light_space_matrices[cascade_index] * vec4(frag_pos, 1.0);
    vec3 projection_coords = frag_pos_light_space.xyz / frag_pos_light_space.w;
    // transform to [0,1] range
    projection_coords = projection_coords * 0.5 + 0.5;

    float current_depth = projection_coords.z;
    if (current_depth > 1.0)
        return 0.0;

    float bias = max(0.005 * (1.0 - clamp(dot(normal, light_dir), 0.0, 1.0)), cascaded_shadows_parameters.shadow_bias);
    
    float shadow = 0.0f;
    if (cascaded_shadows_parameters.soft_shadows == 1) {
        shadow = shadow_pcf(projection_coords.xy, current_depth, bias, cascade_index);
    } else {
        shadow = shadow_hard(projection_coords.xy, current_depth, bias, cascade_index);
    }
    
    return shadow;
}

vec3 calculate_directional_light_luminance(directional_light dir_light, vec3 normal, vec3 view_dir, vec3 frag_pos, vec3 albedo, vec3 F0, float roughness, float metallic) {
    vec3 L = normalize(-dir_light.direction.xyz);
    vec3 H = normalize(view_dir + L);

    vec3 radiance = dir_light.color.rgb;

    // cook-torrance brdf
    float NDF = distribution_ggx(normal, H, roughness);
    float G = geometry_smith(normal, view_dir, L, roughness);
    vec3 F = fresnel_schlick(max(dot(H, view_dir), 0.0), F0);
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;

    vec3 numerator = NDF * G * F;
    float denominator = 4.0 * max(dot(normal, view_dir), 0.0) * max(dot(normal, L), 0.0);
    vec3 specular = numerator / max(denominator, 0.001);
    float NdotL = max(dot(normal, L), 0.0);

    float shadow = calculate_directional_light_shadow(frag_pos, normal, L);
    vec3 final = (1 - shadow) * (kD * albedo / PI + specular) * radiance * NdotL;

    float intensity = dir_light.color.a;
    final *= intensity;

    return final;
}

vec3 calculate_point_light_luminance(point_light point_light, vec3 normal, vec3 view_dir, vec3 reflect_dir, vec3 frag_pos, vec3 albedo, vec3 F0, float roughness, float metallic) {
    /*    
    // Lambertian diffuse reflection
        vec3 light_dir = normalize(point_light.position.xyz - frag_pos);
        
        float distance = length(point_light.position.xyz - frag_pos);
        float attenuation = 1.0 / (point_light_constant + point_light_linear * distance + point_light_quadratic * (distance * distance));
        float NdotL = max(dot(normalize(normal), light_dir), 0.0);
        
        vec3 diffuse = albedo / PI;
        
        // Cook-Torrance specular reflection
        vec3 specular = cook_torrance_brdf(normalize(normal), view_dir, light_dir, roughness, F0);
        
        // Final lighting equation with attenuation
        float intensity = point_light.color.a;
        vec3 luminance = attenuation * NdotL * max(diffuse + specular, vec3(0.0)) * point_light.color.rgb * intensity;
        
            
        float shadow = calculate_point_shadow(point_light, frag_pos);
            
        return (1-shadow) * luminance;
    */
    vec3 L = normalize(point_light.position.xyz - frag_pos);
    vec3 H = normalize(view_dir + L);

    float distance = length(point_light.position.xyz - frag_pos);
    float attenuation = 1.0 / (point_light_constant + point_light_linear * distance + point_light_quadratic * (distance * distance));
    vec3 radiance = point_light.color.rgb * attenuation;

    // cook-torrance brdf
    float NDF = distribution_ggx(normal, H, roughness);
    float G = geometry_smith(normal, view_dir, L, roughness);
    vec3 F = fresnel_schlick(max(dot(H, view_dir), 0.0), F0);
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    vec3 numerator = NDF * G * F;
    float denominator = 4.0 * max(dot(normal, view_dir), 0.0) * max(dot(normal, L), 0.0);
    vec3 specular = numerator / max(denominator, 0.001);
    // add to outgoing radiance Lo
    float NdotL = max(dot(normal, L), 0.0);

    //float shadow = 0;
    vec3 final = (kD * albedo / PI + specular) * radiance * NdotL;

    return final;
}

void main()
{
    vec3 frag_pos = texture(u_position_map, o_tex_coord).rgb;
    vec4 full_albedo = texture(u_albedo_map, o_tex_coord);
    vec3 albedo = pow(full_albedo.rgb, vec3(2.2));
    vec3 normal = normalize(texture(u_normal_map, o_tex_coord).rgb);
    vec3 rough_metal_ao = texture(u_rough_metal_ao_map, o_tex_coord).rgb;
    vec3 emissive = texture(u_emissive_map, o_tex_coord).rgb;

    float opacity = full_albedo.a;
    float roughness = rough_metal_ao.r;
    float metallic = rough_metal_ao.g;
    float ambient_occlusion = rough_metal_ao.b;

    float world_ambient_occlusion = texture(u_ambient_occlusion_map, o_tex_coord).r;
    //ambient_occlusion *= world_ambient_occlusion;
    //ambient_occlusion /= 2;

    vec3 view_dir = normalize(camera.position.xyz - frag_pos);
    vec3 reflect_dir = reflect(-view_dir, normal);

    vec3 F0 = vec3(0.04);
    F0 = mix(F0, albedo, metallic);

    vec3 luminance = calculate_directional_light_luminance(lights.directional_light, normal, view_dir, frag_pos, albedo, F0, roughness, metallic);
    /*
           
       for (int i = 0; i < 1; i++) {
           luminance += calculate_point_light_luminance(lights.point_lights[i], normal, view_dir, reflect_dir, frag_pos, albedo, F0, roughness, metallic);   
       }
         /*
       for (int i = 0; i < 16; i++) {
           luminance += calculate_spot_light_luminance(lights.spot_lights[i], normal, view_dir, frag_pos, albedo, F0, roughness, metallic);
       }
           */


    vec3 F = fresnel_schlick_roughness(max(dot(normal, view_dir), 0.0), F0, roughness);

    vec3 kS = F;
    vec3 kD = 1.0 - kS;
    kD *= 1.0 - metallic;

    vec3 irradiance = sample_irradiance_map(normal);
    vec3 diffuse      = irradiance * albedo;

    vec3 prefilter = sample_prefilter_map(reflect_dir, roughness);
    vec2 brdf_lut = sample_brdf_lut_map(view_dir, normal, roughness);
    vec3 specular = prefilter * (F * brdf_lut.x + brdf_lut.y);

    vec3 ambient = (kD * diffuse + specular)  * u_skybox_intensity * u_skybox_tint.rgb * ambient_occlusion;

    vec3 color = ambient + luminance + emissive;

    frag_color = vec4(color, full_albedo.a);
}